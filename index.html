<html>

<head>
    <title>Live Performance</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="./css/style.css">
</head>

<body>
    <script src='./js/randData/audiance.js'></script>
    <script src="js/libs/three.js"></script>
    <script src="js/libs/tween.min.js"></script>
    <script src="js/libs/TrackballControls.js"></script>
    <script src="js/CSS3DRenderer.js"></script>
    <script src="./js/star.js"></script>
    <script src='js/Planet.js'></script>
    <canvas id="starContainer" class='star-container'></canvas>
    <video id="video" autoplay="true"></video>
    <input type="file" id="thefile" accept="audio/*" />
    <audio id="audio" src='./media/testMusic.mp3' autoplay controls></audio>
    <div id="container"></div>
    <script>
        let likeDomain = [], commentDomain = [], ringRange = [1, 5], scene;

        const scaleRing = (val, domain, range) => {
            return range[0] + ((val - domain[0]) / (domain[1] - domain[0])) * (range[1] - range[0]);
        }

        const dynamicRScale = (r, domain) => {
            const range = [80, 120];
            return range[0] + (range[1] - range[0]) * (r - domain[0]) / (domain[1] - domain[0]);
        }

        const loadAudio = (file) => {
            const audio = document.getElementById('audio');
            audio.src = URL.createObjectURL(file);
            audio.load();
            audio.play();
            var context = new AudioContext();
            var src = context.createMediaElementSource(audio);
            var analyser = context.createAnalyser();

            src.connect(analyser);
            analyser.connect(context.destination);
            analyser.fftSize = 256;
            var bufferLength = analyser.frequencyBinCount;

            var dataArray = new Uint8Array(bufferLength);

            let count = 0;
            const colors = [[65, 32, 137], [17, 101, 171], [58, 176, 53], [245, 182, 27], [231, 32, 25]];
            function renderFrame() {
                requestAnimationFrame(renderFrame);
                if (count % 60 === 0) {
                    analyser.getByteFrequencyData(dataArray);
                    timeGap = Math.random() * 60 + 100;
                    dataArray = dataArray.sort().reverse();
                    let r = dynamicRScale(dataArray[0], [120, dataArray[0]]);
                    const data = {
                        name: 'userX',
                        like: Math.ceil(Math.random() * 30 + 20),
                        comment: Math.ceil(Math.random() * 15 + 5)
                    }
                    const tmpPlanet = createPlanet(data, r, [], false, false);
                    transformOnePlanet(tmpPlanet, 10000);
                }
                count++;
            }

            renderFrame();
        }

        var file = document.getElementById("thefile");
        file.onchange = function () {
            var files = this.files;
            loadAudio(files[0]);
        }

        const loadCameraOnHidden = () => {
            const canvas = document.getElementById('cameraCanvas');
            const video = document.getElementById('video');
            const ctx = canvas.getContext('2d');
            if (navigator.mediaDevices.getUserMedia) {
                var successCallback = function (stream) {
                    video.srcObject = stream;
                };
                var errorCallback = function (error) {
                    console.log(error);
                };
                navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: { facingMode: 'environment' }
                }).then(successCallback, errorCallback);
                requestAnimationFrame(renderFrame);
            }

            function renderFrame() {
                requestAnimationFrame(renderFrame);
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    ctx.drawImage(video, 0, 0, 800, 600);
                }
            }
            renderFrame();
        }

        // const createPlanet = (data, size, objects, adding, randomCoords) => {
        //     var element = document.createElement('div');
        //     element.className = 'element';
        //     element.style.width = size + 'px';
        //     element.style.height = size + 'px';

        //     const likeRing = document.createElement('div');
        //     likeRing.className = 'like-ring';
        //     const likeBorder = scaleRing(data.like, likeDomain, ringRange);
        //     likeRing.style.width = (size + padding * 2 + likeBorder) + 'px';
        //     likeRing.style.height = (size + padding * 2 + likeBorder) + 'px';
        //     likeRing.style.borderWidth = likeBorder + 'px';

        //     const commentRing = document.createElement('div');
        //     commentRing.className = 'comment-ring';
        //     const commentBorder = scaleRing(data.comment, commentDomain, ringRange);
        //     commentRing.style.width = (size + padding * 4 + commentBorder + likeBorder * 2) + 'px';
        //     commentRing.style.height = (size + padding * 4 + commentBorder + likeBorder * 2) + 'px';
        //     commentRing.style.borderWidth = commentBorder + 'px';

        //     const eleObj = new THREE.CSS3DObject(element);
        //     const x = randomCoords ? Math.random() * 3000 - 1000 : 0;
        //     const y = randomCoords ? Math.random() * 3000 - 1000 : 0;
        //     const z = randomCoords ? Math.random() * 3000 - 1000 : -100;
        //     eleObj.position.x = x;
        //     eleObj.position.y = y;
        //     eleObj.position.z = z;

        //     const likeRingObj = new THREE.CSS3DObject(likeRing);
        //     likeRingObj.position.x = x;
        //     likeRingObj.position.y = y;
        //     likeRingObj.position.z = z;
        //     likeRingObj.rotation.x = Math.random() * Math.PI * 2;
        //     likeRingObj.rotation.y = Math.random() * Math.PI * 2;
        //     likeRingObj.rotation.z = Math.random() * Math.PI * 2;

        //     const commentRingObj = new THREE.CSS3DObject(commentRing);
        //     commentRingObj.position.x = x;
        //     commentRingObj.position.y = y;
        //     commentRingObj.position.z = z;
        //     commentRingObj.rotation.x = Math.random() * Math.PI * 2;
        //     commentRingObj.rotation.y = Math.random() * Math.PI * 2;
        //     commentRingObj.rotation.z = Math.random() * Math.PI * 2;

        //     const group = new THREE.Group();
        //     group.add(eleObj);
        //     group.add(likeRingObj);
        //     group.add(commentRingObj);

        //     scene.add(group);
        //     if (adding) {
        //         objects.push(group);
        //     }
        //     return group;
        // }

        var camera, renderer, cameraCanvas;
        var controls;

        var objects = [];
        var targets = { grid: [] };
        const padding = 12;

        Star.initAllStars();
        Star.animateAllStars();
        init();
        animate();
        loadCameraOnHidden(cameraCanvas);
        loadAudio();

        function init() {
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 3000;

            scene = new THREE.Scene();

            // for (let i = 0; i < 300; i++) {
            //     let obj = {};
            //     obj.name = 'user' + i;
            //     obj.like = Math.ceil(Math.random() * 40 + 10);
            //     obj.comment = Math.ceil(Math.random() * 15 + 5);
            //     console.log(JSON.stringify(obj));
            // }

            //calculate like border scale
            let minLike = 1000000, maxLike = 0, minComment = 1000000, maxComment = 0;
            randAudiance.forEach(item => {
                minLike = minLike > item.like ? item.like : minLike;
                maxLike = maxLike < item.like ? item.like : maxLike;
                minComment = minComment > item.comment ? item.comment : minComment;
                maxComment = maxComment < item.comment ? item.comment : maxComment;
            })

            likeDomain = [minLike, maxLike];
            commentDomain = [minComment, maxComment];
            // randAudiance
            for (var i = 0; i < randAudiance.length; i++) {
                const size = Math.random() * 100 + 80;
                const x = Math.random() * 2000 - 1000;
                const y = Math.random() * 2000 - 1000;
                const z = Math.random() * 5000 - 2500;
                const tmpPlanet = new Planet(scene, randAudiance[i], size, { x: x, y: y, z: z });
                tmpPlanet.createPlanet(true, [likeDomain, commentDomain]);
                // createPlanet(randAudiance[i], size, objects, true, true);
            }
            Planet.generateTargetPosi();


            //init video container
            const cameraContainer = document.createElement('div');
            const videoSize = 600;
            cameraContainer.className = 'camera-container';
            cameraContainer.style.width = videoSize + 'px';
            cameraContainer.style.height = videoSize + 'px';
            const cameraCanvas = document.createElement('canvas');
            cameraCanvas.id = 'cameraCanvas';
            cameraCanvas.width = videoSize;
            cameraCanvas.height = videoSize;
            cameraContainer.appendChild(cameraCanvas);
            const coverImg = document.createElement('img');
            coverImg.src = './images/bubble_blue.png';
            cameraContainer.appendChild(coverImg);

            const cameraObj = new THREE.CSS3DObject(cameraContainer);
            cameraObj.position.x = 0;
            cameraObj.position.y = 0;
            cameraObj.position.z = 0;
            scene.add(cameraObj);

            renderer = new THREE.CSS3DRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.TrackballControls(camera, renderer.domElement);
            controls.rotateSpeed = 0.5;
            controls.minDistance = 500;
            controls.maxDistance = 6000;
            controls.addEventListener('change', render);

            Planet.transformTargetPosis(80000);

            window.addEventListener('resize', onWindowResize, false);
        }

        function transformOnePlanet(object, duration) {
            const targetX = Math.random() * 2000 - 1000;
            const targetY = Math.random() * 2000 - 1000;
            const targetZ = Math.random() * 5000 - 2500;
            new TWEEN.Tween(object.position)
                .to({ x: targetX, y: targetY, z: targetZ }, Math.random() * duration + duration)
                .easing(TWEEN.Easing.Exponential.InOut)
                .start();
            new TWEEN.Tween(this)
                .to({}, duration * 2)
                .onUpdate(render)
                .start();
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            render();

        }

        function animate() {

            requestAnimationFrame(animate);

            TWEEN.update();

            controls.update();

        }

        function render() {

            renderer.render(scene, camera);

        }

    </script>


</body>

</html>